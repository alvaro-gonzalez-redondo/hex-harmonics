<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>HexBoard - Maupin/Piano Layout</title>
    <style>
        body { background: #121212; color: #eee; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .panel { background: #2a2a2a; padding: 15px; border-radius: 10px; margin-bottom: 20px; display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .control-group { display: flex; flex-direction: column; gap: 5px; min-width: 120px; }
        select, input, button { padding: 6px; border-radius: 4px; border: 1px solid #555; background: #333; color: white; cursor: pointer; }
        button:hover { background: #555; }
        canvas { cursor: crosshair; box-shadow: 0 0 30px rgba(0,0,0,0.8); border-radius: 4px; background: #050505; }
        .legend { display: flex; gap: 15px; font-size: 0.85em; margin-top: 10px; flex-wrap: wrap; justify-content: center;}
        .dot { width: 10px; height: 10px; display: inline-block; border-radius: 50%; margin-right: 5px; border: 1px solid #555; }
    </style>
</head>
<body>

    <div class="panel">
        <div class="control-group">
            <label>Afinación (TET):</label>
            <select id="tetSelect" onchange="initSystem()">
                <option value="12">12-TET (Piano Std)</option>
                <option value="19">19-TET (Extended)</option>
                <option value="31" selected>31-TET (Huygens)</option>
                <option value="53">53-TET (Turkish)</option>
            </select>
        </div>
        <div class="control-group">
            <label>Distribución (Layout):</label>
            <select id="layoutSelect" onchange="initSystem()">
                <option value="maupin" selected>Maupin / Jankó (Piano-like)</option>
                <option value="wicki">Wicki-Hayden (Compacto)</option>
            </select>
        </div>
        <div class="control-group">
            <label>Tolerancia Visual:</label>
            <input type="range" id="sens" min="1" max="80" value="25" oninput="updateHeatmap()">
        </div>
        <div class="control-group">
            <label>Acciones:</label>
            <button onclick="clearBoard()">Limpiar Todo</button>
        </div>
    </div>

    <canvas id="hexCanvas" width="950" height="500"></canvas>

    <div class="legend">
        <span><span class="dot" style="background:#555; border-color: #888;"></span>Tecla Natural (Blanca)</span>
        <span><span class="dot" style="background:#222; border-color: #333;"></span>Alteración (Negra)</span>
        <span style="margin-left:15px">|</span>
        <span><span class="dot" style="background:cyan;"></span>3-Limit (5tas)</span>
        <span><span class="dot" style="background:#ffcc00;"></span>5-Limit (3ras)</span>
        <span><span class="dot" style="background:#ff00ff;"></span>7-Limit (Septimal)</span>
        <span><span class="dot" style="background:#ff4444;"></span>11-Limit (Neutro)</span>
    </div>

<script>
const canvas = document.getElementById('hexCanvas');
const ctx = canvas.getContext('2d');
const HEX_SIZE = 20;
const ROWS = 19;
const COLS = 7;

// --- DEFINICIÓN DE TECLAS "BLANCAS" (Naturales) POR TET ---
const WHITE_KEYS = {
    12: [0, 2, 4, 5, 7, 9, 11],
    19: [0, 3, 6, 8, 11, 14, 17],
    31: [0, 5, 10, 13, 18, 23, 28],
    41: [0, 7, 14, 17, 24, 31, 38],
    53: [0, 9, 18, 22, 31, 40, 49]
};

// Pasos de semitono y tono por TET
const TET_STEPS = {
    12: { semitone: 1, wholetone: 2, fifth: 7 },
    19: { semitone: 2, wholetone: 3, fifth: 11 },  // En 19-TET el "semitono diatónico" es 2 pasos
    31: { semitone: 3, wholetone: 5, fifth: 18 },  // En 31-TET
    53: { semitone: 5, wholetone: 9, fifth: 31 }
};

// Intervalos Justos para colorear
const JUST_INTERVALS = [
    { name: "Unison", ratio: 1/1, limit: 1, color: [255, 255, 255] },
    { name: "Octave", ratio: 2/1, limit: 2, color: [255, 255, 255] },
    { name: "Fifth",  ratio: 3/2, limit: 3, color: [0, 255, 255] },
    { name: "Fourth", ratio: 4/3, limit: 3, color: [0, 255, 255] },
    { name: "M3",     ratio: 5/4, limit: 5, color: [255, 204, 0] },
    { name: "m3",     ratio: 6/5, limit: 5, color: [255, 204, 0] },
    { name: "M6",     ratio: 5/3, limit: 5, color: [255, 204, 0] },
    { name: "m6",     ratio: 8/5, limit: 5, color: [255, 204, 0] },
    { name: "H7",     ratio: 7/4, limit: 7, color: [255, 0, 255] },
    { name: "S3",     ratio: 7/6, limit: 7, color: [255, 0, 255] },
    { name: "Tritone",ratio: 7/5, limit: 7, color: [255, 0, 255] },
    { name: "Neu3",   ratio: 11/9, limit: 11, color: [255, 60, 60] }
];

let keys = [];
let currentTET = 31;
let currentLayout = 'maupin';

function initSystem() {
    currentTET = parseInt(document.getElementById('tetSelect').value);
    currentLayout = document.getElementById('layoutSelect').value;
    initKeys();
    updateHeatmap();
}

function initKeys() {
    keys = [];
    const steps = TET_STEPS[currentTET] || TET_STEPS[12];

    // --- 1. GEOMETRÍA (Pointy-Topped) ---
    // Pointy-top es mejor para teclados porque el zig-zag es horizontal.
    // Width = sqrt(3) * size
    // Height = 2 * size
    const hexWidth = HEX_SIZE*3;// * Math.sqrt(3);
    const hexHeight = HEX_SIZE*0.9;

    // Distancias para empaquetado compacto (Honeycomb)
    const horizSpacing = hexWidth;
    const vertSpacing = hexHeight; // 3/4 de la altura para encajar

    // Centro lógico
    const centerCol = Math.floor(COLS / 2);
    const centerRow = Math.floor(ROWS / 2);

    for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {

            // --- 2. POSICIÓN VISUAL ---
            // "Offset coords": Desplazamos las filas impares a la derecha
            // para que encajen en los huecos de la fila anterior.
            let xPos = col * horizSpacing;
            let yPos = row * vertSpacing + 50;

            // Stagger: Si la fila es impar, sumamos medio ancho
            if (row % 2 !== 0) {
                xPos += horizSpacing / 2;
            }
            xPos += 50; // Margen global

            // --- 3. LÓGICA MUSICAL (Vectores) ---
            // Convertimos de (col, row) a Coordenadas Axiales (q, r)
            // Esto simplifica enormemente la lógica isomórfica.
            // Referencia: "Offset coordinates to Axial coordinates"

            // Ajustamos col para que el centro sea (0,0)
            const c = col - centerCol;
            const rOffset = centerRow - row; // Invertimos Y para que 'arriba' sea positivo

            // Conversión para layout "Odd-R" (filas impares desplazadas)
            // q = eje diagonal, r = eje vertical/diagonal
            const q = c - Math.floor((row - centerRow - ((row - centerRow) & 1)) / 2);
            const r = rOffset;

            let rawIndex = 0;

            if (currentLayout === 'wicki-hayden') {
                // WICKI-HAYDEN ESTÁNDAR:
                // Eje Q (Derecha): Tono Entero (+2)
                // Eje R (Arriba-Derecha): Quinta (+7)
                // Esto genera automáticamente las cuartas (+5) hacia Arriba-Izquierda

                rawIndex = (q * steps.wholetone) + (r * steps.fifth);

            } else if (currentLayout === 'maupin') {
                // JANKÓ (Adaptado a Hex):
                // Horizontal: Tono entero
                // Vertical/Diagonal: Semitono
                // Nota: Jankó es nativamente rectangular, en hexágonos se adapta
                // haciendo que la fila superior sea +1 semitono.

                // Usamos las coordenadas visuales directas para Jankó
                // porque Jankó no usa ejes diagonales, sino filas estrictas.
                /*
                const visualX = col - centerCol;
                const visualY = centerRow - row;


                rawIndex = (visualX * steps.wholetone) + (visualY * steps.semitone);

                // Corrección del stagger visual para Jankó:
                // Si movemos una fila visualmente, corregimos la afinación
                if (row % 2 !== 0) {
                     rawIndex -= Math.floor(steps.semitone);
                }
                */

                let parity = (row%2)==1;
                let _col = col*2 + parity;
                let _row = Math.floor(row/2);
                let q = _col;
                let r = -(_row - (_col-parity)/2);

                rawIndex = r;
            }

            // --- 4. PROCESAMIENTO ESTÁNDAR ---

            // Calcular frecuencia (C4 en el centro, índice 0)
            const freq = 261.63 * Math.pow(2, rawIndex / currentTET);

            // Normalizar nota (0 a 11 en 12-TET)
            // El + (currentTET * 1000) es para evitar números negativos en el módulo
            const noteLabel = Math.floor(((rawIndex % currentTET) + (currentTET * 1000)) % currentTET);

            // Coloreado
            const whiteSet = WHITE_KEYS[currentTET] || WHITE_KEYS[12];
            const isWhite = whiteSet.includes(noteLabel);
            const isAnchor = (noteLabel === 0); // Do / C

            keys.push({
                x: xPos,
                y: yPos,
                freq: freq,
                noteIndex: noteLabel,
                rawIndex: rawIndex,
                isAnchor: isAnchor,
                isWhite: isWhite,
                // Debug properties
                coord: {q, r, c: col, r: row}
            });
        }
    }
}

function complexRoughness(f1, f2) {
    let rTotal = 0;
    for (let i = 1; i <= 4; i++) {
        for (let j = 1; j <= 4; j++) {
            const p1 = f1 * i, p2 = f2 * j;
            const amp = (1/i) * (1/j);
            const fMin = Math.min(p1, p2), fMax = Math.max(p1, p2);
            const diff = fMax - fMin;
            const cbw = 5 + 10 * fMin / 1000;
            if (diff < cbw * 2.5) {
                const x = diff / cbw;
                rTotal += (x * Math.exp(1 - x)) * amp;
            }
        }
    }
    return rTotal;
}

function updateHeatmap() {
    const activeKeys = keys.filter(k => k.active);
    const sliderVal = parseInt(document.getElementById('sens').value);
    const gain = sliderVal / 10;

    keys.forEach(target => {
        // Colores base para piano visual
        const baseColor = target.isWhite ? [90, 90, 90] : [30, 30, 30];

        if (target.active) {
            target.litColor = [255, 255, 255];
            target.litBrightness = 1.0;
            return;
        }

        if (activeKeys.length > 0) {
            let totalRoughness = 0;
            let minCentsDiff = 1000;
            let harmonicColor = [...baseColor];

            activeKeys.forEach(source => {
                totalRoughness += complexRoughness(source.freq, target.freq);

                let ratio = target.freq / source.freq;
                if (ratio < 1) ratio = 1 / ratio;
                while (ratio > 2.01) ratio /= 2;

                JUST_INTERVALS.forEach(ji => {
                    const diff = Math.abs(ratio - ji.ratio);
                    if (diff < 0.035 && diff < minCentsDiff) {
                        minCentsDiff = diff;
                        harmonicColor = [...ji.color];
                    }
                });
            });

            const consonance = 1 / (1 + (totalRoughness * (8 / gain)));

            if (minCentsDiff < 0.04) {
                target.litColor = harmonicColor;
                target.litBrightness = Math.max(consonance, 0.25);
            } else {
                target.litColor = baseColor;
                target.litBrightness = consonance * 0.4;
            }

        } else {
            target.litColor = baseColor;
            target.litBrightness = 1.0;
        }
    });

    drawBoard();
}

function drawHexagon(x, y, size, flatTop = true) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        // Para flat-top, empezamos en 0°; para pointy-top, en 30°
        const angleOffset = flatTop ? 0 : Math.PI / 6;
        const angle = (Math.PI / 3) * i + angleOffset;
        const px = x + size * Math.cos(angle);
        const py = y + size * Math.sin(angle);
        if (i === 0) {
            ctx.moveTo(px, py);
        } else {
            ctx.lineTo(px, py);
        }
    }
    ctx.closePath();
}

function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    keys.forEach(k => {
        let r, g, b;
        if (k.active) {
            r = 255; g = 255; b = 255;
        } else {
            r = Math.floor(k.litColor[0] * k.litBrightness);
            g = Math.floor(k.litColor[1] * k.litBrightness);
            b = Math.floor(k.litColor[2] * k.litBrightness);
        }

        // Dibujar hexágono flat-top
        drawHexagon(k.x, k.y, HEX_SIZE - 1, true);

        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fill();

        // Bordes
        if (k.isAnchor) {
            ctx.strokeStyle = "rgba(255, 200, 100, 0.9)";
            ctx.lineWidth = 2.5;
        } else {
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;
        }
        ctx.stroke();

        // Texto
        if (k.litBrightness > 0.15 || k.active) {
            const brightness = r + g + b;
            ctx.fillStyle = brightness > 350 ? "#000" : "#aaa";
            ctx.font = "bold 9px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(k.noteIndex, k.x, k.y);
        }
    });
}

// --- EVENTOS ---
function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
}

canvas.addEventListener('mousedown', function(evt) {
    const mouse = getMousePos(evt);
    let clicked = false;

    keys.forEach(k => {
        const dist = Math.sqrt((mouse.x - k.x) ** 2 + (mouse.y - k.y) ** 2);
        if (dist < HEX_SIZE * 0.9) {
            k.active = !k.active;
            clicked = true;
        }
    });

    if (clicked) updateHeatmap();
});

function clearBoard() {
    keys.forEach(k => k.active = false);
    updateHeatmap();
}

// Iniciar
initSystem();
</script>
</body>
</html>
